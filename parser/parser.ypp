%{
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cstdlib> //-- I need this for atoi

#include "SemValue.h"
#include "Tree.h" // abstract syntax tree

//-- Lexer prototype required by bison, aka getNextToken()
int yylex();
int yyerror(const char *p) { std::cerr << "Error!" << std::endl; }
%}

//-- SYMBOL SEMANTIC VALUES -----------------------------
%token <sym> DATABASE DATABASES TABLE TABLES SHOW CREATE
%token <sym> DROP USE CHECK PRIMARY KEY UNIQUE
%token <sym> NOT NIL AUTO_INCREMENT INSERT INTO VALUES
%token <sym> DELETE FROM WHERE UPDATE SET SELECT
%token <sym> GROUP BY IS IN BETWEEN LIKE
%token <sym> AND OR SUM AVG MAX MIN
%token <sym> INT SMALLINT BIGINT FLOAT REAL DOUBLE
%token <sym> VARCHAR STRING CHAR BOOLEAN DATETIME
%token <sym> EQ NE LE GE LT GT
%token <sym> LP RP COMMA STOP DOT
%token <sym> PLUS MINUS MUL DIV MOD
%token <sym> DESC FOREIGN REFERENCES
%token <value> VALUE
%token <ident> IDENT

%type <tree> program stmt sysStmt dbStmt tbStmt type boolExpr columns eq selector where groupBy selectors expr field col
%type <tlist> fields stmts set eqs sellist
%type <integer> attr func
%type <ilist> attrs
%type <slist> idents

%left OR
%left AND
%left ADD SUB
%left MUL DIV MOD

//-- GRAMMAR RULES ---------------------------------------
%%
program     :   stmts
                {
                    $$ = new TopLevel($1);
                    PrintWriter pw;
                    $$->printTo(pw);
                }
            ;

stmts       :   /* empty */
                {
                    $$ = new std::vector<Tree*>;
                }
            |   stmts stmt
                {
                    $$ = $1;
                    $$->push_back($2);
                }
            ;

stmt        :   sysStmt STOP
            |   dbStmt STOP
            |   tbStmt STOP
            ;

sysStmt     :   SHOW DATABASES
                {
                    $$ = new ListDB;
                }
            ;

dbStmt      :   CREATE DATABASE IDENT
                {
                    $$ = new CreateDBStmt($3);
                }
            |   DROP DATABASE IDENT
                {
                    $$ = new DropDBStmt($3);
                }
            |   USE IDENT
                {
                    $$ = new UseDBStmt($2);
                }
            |   SHOW TABLES
                {
                    $$ = new ListTB;
                }
            ;

tbStmt      :   CREATE TABLE IDENT LP fields RP
                {
                    $$ = new CreateTBStmt($3, $5);
                }
            |   DROP TABLE IDENT
                {
                    $$ = new DropTBStmt($3);
                }
            |   SHOW TABLE IDENT
                {
                    $$ = new ShowTBStmt($3);
                }
            |   DESC IDENT
                {
                    $$ = new ShowTBStmt($2);
                }
            |   INSERT INTO IDENT columns VALUES LP set RP
                {
                    $$ = new InsertStmt($3, $4, $7);
                }
            |   DELETE FROM IDENT WHERE boolExpr
                {
                    $$ = new DeleteStmt($3, $5);
                }
            |   UPDATE IDENT SET eqs WHERE boolExpr
                {
                    $$ = new UpdateStmt($2, $4, $6);
                }
            |   SELECT selectors FROM IDENT where groupBy
                {
                    $$ = new SelectStmt($4, $2, $5, $6);
                }
            ;

fields      :   field
                {
                    $$ = new std::vector<Tree*>;
                    $$->push_back($1);
                }
            |   fields COMMA field
                {
                    $$ = $1;
                    $$->push_back($3);
                }
            ;

field       :   IDENT type attrs
                {
                    $$ = new Field($2, $1, $3);
                }
            |   CHECK LP boolExpr RP
                {
                    $$ = new Check($3);
                }
            |   PRIMARY KEY LP IDENT RP
                {
                    $$ = new PrimaryKey($4);
                }
            |   FOREIGN KEY LP IDENT RP REFERENCES IDENT LP IDENT RP
                {
                    $$ = new ForeignKey($4, $7, $9);
                }
            ;

type        :   INT
                {
                    $$ = new Type(Type::TYPE_INT);
                }
            |   INT LP VALUE RP
                {
                    $$ = new Type(Type::TYPE_INT, $3);
                }
            |   SMALLINT
                {
                    $$ = new Type(Type::TYPE_SMALL_INT);
                }
            |   BIGINT
                {
                    $$ = new Type(Type::TYPE_BIG_INT);
                }
            |   FLOAT
                {
                    $$ = new Type(Type::TYPE_FLOAT);
                }
            |   DOUBLE
                {
                    $$ = new Type(Type::TYPE_DOUBLE);
                }
            |   VARCHAR LP VALUE RP
                {
                    $$ = new Type(Type::TYPE_STRING, $3);
                }
            |   STRING
                {
                    $$ = new Type(Type::TYPE_STRING);
                }
            |   CHAR
                {
                    $$ = new Type(Type::TYPE_CHAR);
                }
            |   BOOLEAN
                {
                    $$ = new Type(Type::TYPE_BOOLEAN);
                }
            |   DATETIME
                {
                    $$ = new Type(Type::TYPE_DATETIME);
                }
            ;

attrs       :   /* empty */
                {
                    $$ = new std::vector<int>;
                }
            |   attrs attr
                {
                    $$ = $1;
                    $$->push_back($2);
                }
            ;

attr        :   NOT NIL
                {
                    $$ = Field::ATTR_NOT_NULL;
                }
            |   UNIQUE
                {
                    $$ = Field::ATTR_UNIQUE;
                }
            |   AUTO_INCREMENT
                {
                    $$ = Field::ATTR_AUTO_INCREMENT;
                }
            ;

col         :   IDENT
                {
                    $$ = new Col($1);
                }
            |   IDENT DOT IDENT
                {
                    $$ = new Col($1, $3);
                }
            ;

boolExpr    :   col IS NIL
                {
                    $$ = new NullExpr($1, BoolExpr::OP_IS_NULL);
                }
            |   col IS NOT NIL
                {
                    $$ = new NullExpr($1, BoolExpr::OP_IS_NOT_NULL);
                }
            |   col IN LP set RP
                {
                    $$ = new InExpr($1, $4, BoolExpr::OP_IN);
                }
            |   col NOT IN LP set RP
                {
                    $$ = new InExpr($1, $5, BoolExpr::OP_NOT_IN);
                }
            |   col BETWEEN VALUE AND VALUE
                {
                    $$ = new BetweenExpr($1, $3, $5, BoolExpr::OP_BETWEEN);
                }
            |   col NOT BETWEEN VALUE AND VALUE
                {
                    $$ = new BetweenExpr($1, $4, $6, BoolExpr::OP_NOT_BETWEEN);
                }
            |   col LIKE VALUE
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_LIKE);
                }
            |   col NOT LIKE VALUE
                {
                    $$ = new CompareExpr($1, $4, BoolExpr::OP_NOT_LIKE);
                }
            |   col EQ expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_EQ);
                }
            |   col NE expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_NE);
                }
            |   col GE expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_GE);
                }
            |   col LE expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_LE);
                }
            |   col GT expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_GT);
                }
            |   col LT expr
                {
                    $$ = new CompareExpr($1, $3, BoolExpr::OP_LT);
                }
            |   LP boolExpr RP
                {
                    $$ = $2;
                }
            |   boolExpr AND boolExpr
                {
                    $$ = new ComplexExpr($1, $3, BoolExpr::OP_AND);
                }
            |   boolExpr OR boolExpr
                {
                    $$ = new ComplexExpr($1, $3, BoolExpr::OP_OR);
                }
            ;

set         :   VALUE
                {
                    $$ = new std::vector<Tree*>;
                    $$->push_back($1);
                }
            |   set COMMA VALUE
                {
                    $$ = $1;
                    $$->push_back($3);
                }
            ;

columns     :   /* empty */
                {
                    $$ = new Columns;
                }
            |   LP idents RP
                {
                    $$ = new Columns($2);
                }
            ;

idents      :   IDENT
                {
                    $$ = new std::vector<const char*>;
                    char *tmp = new char[1024];
                    strncpy(tmp, $1, 1024);
                    $$->push_back(tmp);
                }
            |   idents COMMA IDENT
                {
                    $$ = $1;
                    char *tmp = new char[1024];
                    strncpy(tmp, $3, 1024);
                    $$->push_back(tmp);
                }
            ;

eqs         :   eq
                {
                    $$ = new std::vector<Tree*>;
                    $$->push_back($1);
                }
            |   eqs COMMA eq
                {
                    $$ = $1;
                    $$->push_back($3);
                }
            ;

eq          :   IDENT EQ expr
                {
                    $$ = new Eq($1, $3);
                }
            ;

selectors   :   MUL
                {
                    $$ = new Selectors;
                }
            |   sellist
                {
                    $$ = new Selectors($1);
                }
            ;

sellist     :   selector
                {
                    $$ = new std::vector<Tree*>;
                    $$->push_back($1);
                }
            |   sellist COMMA selector
                {
                    $$ = $1;
                    $$->push_back($3);
                }
            ;

selector    :   col
                {
                    $$ = new Selector($1);
                }
            |   func LP col RP
                {
                    $$ = new Selector($1, $3);
                }
            ;

func        :   SUM
                {
                    $$ = Selector::FUNC_SUM;
                }
            |   AVG
                {
                    $$ = Selector::FUNC_AVG;
                }
            |   MAX
                {
                    $$ = Selector::FUNC_MAX;
                }
            |   MIN
                {
                    $$ = Selector::FUNC_MIN;
                }
            ;

where       :   /* empty */
                {
                    $$ = new Where;
                }
            |   WHERE boolExpr
                {
                    $$ = new Where($2);
                }
            ;

groupBy     :   /* empty */
                {
                    $$ = new GroupBy;
                }
            |   GROUP BY IDENT
                {
                    $$ = new GroupBy($3);
                }
            ;

expr        :   VALUE
                {
                    $$ = $1;
                }
            |   IDENT
                {
                    $$ = new Col($1);
                }
            |   IDENT DOT IDENT
                {
                    $$ = new Col($1, $3);
                }
            |   PLUS expr
                {
                    $$ = new UnonExpr($2, Expr::OP_POS);
                }
            |   MINUS expr
                {
                    $$ = new UnonExpr($2, Expr::OP_NEG);
                }
            |   expr PLUS expr
                {
                    $$ = new BinExpr($1, $3, Expr::OP_ADD);
                }
            |   expr MINUS expr
                {
                    $$ = new BinExpr($1, $3, Expr::OP_SUB);
                }
            |   expr MUL expr
                {
                    $$ = new BinExpr($1, $3, Expr::OP_MUL);
                }
            |   expr DIV expr
                {
                    $$ = new BinExpr($1, $3, Expr::OP_DIV);
                }
            |   expr MOD expr
                {
                    $$ = new BinExpr($1, $3, Expr::OP_MOD);
                }
            |   LP expr RP
                {
                    $$ = $2;
                }
            ;

%%
//-- FUNCTION DEFINITIONS ---------------------------------
int main()
{
    yyparse();
    printf("exit!\n");

    return 0;
}
